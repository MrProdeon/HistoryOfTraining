# -----Функция all()-----
# Возвращает Истину, если все элементы переданной ей последовательности истинны
# Или Ложь в противном случае
#
# ----Сигнатура all(iterables)
#
# В качестве iterable может выступать любой итерируемый объект:
#
# список;
# кортеж;
# строка;
# множество;
# словарь и т.д.
#
# print(all[True, True, True]) = True
# print(all[True, False, True]) = False
#
# ----При работе со словарями функция all() будет проверять на соответствие параметрам True именно ключи словаря
#
# dict1 = {0: 'zero', 1: 'one', 2: 'two'}
# dict2 = {'zero': 0, 'one': 1, 'two': 2}
#
# print(all(dict1)) = False
# print(all(dict2)) = True
#
#
# ----Если переданный итерируемый объект пустой, то функция вернет True
#
# print(all[]) = True
# print(all()) = True
# print(all('')) = True
#
#
# ------------------------------------------------------------


# -----Функция any()-----
# Вернет истину если хотя бы один элемент последовательности истина
# Обратите внимание: если переданный объект пуст, то функция any() возвращает значение False
#
# Остальное всё как в all()
#
#
#
# ---- Функции all() and any() в связке с map()
#
# ---Все ли элементы списка больше 10
#
# numbers = [17, 90, 78, 56, 231, 45, 5, 89, 91, 11, 19]
#
# result = all(map(lambda x: x > 10, numbers))
#
# if result:
#     print('Все числа больше 10')
# else:
#     print('Хотя бы одно число меньше или равно 10')
#
#
# --- Хотя бы один элемент четное число
#
# numbers = [17, 91, 78, 55, 231, 45, 5, 89, 99, 11, 19]
#
# result = any(map(lambda x: x % 2 == 0, numbers))
#
# if result:
#     print('В списке есть четное число')
# else:
#     print('Все числа нечетные')
#
#
# ----------------------------------------------------------------


# -----Функция enumerate()-----
#
# Возвращает кортеж из индекса элемента и самого элемента переданной последоствальности
# Сигнатура enumerate(iterable, start)
#
# В качестве iterable может выступать любой итерируемый объект:
#
# список;
# кортеж;
# строка;
# множество;
# словарь и т.д.
#
# Необязательный параметр star может показать с какого индекса будет идти отсчет
#
#
#
# colors = ['red', 'green', 'blue']
#
# rs1 = enumerate(colors) = <enumerate object at 0x...>
# rs2 = list(enumerate(colors)) = [(0, 'red'), (1, 'green'), (2, 'blue')]
#
#
# colors = ['red', 'green', 'blue']
# for index,item in enumerate(colors):
#     print(index,item)
#
# 0 red
# 1 green
# 2 blue
#
#
# --------------------------------------------------------------------------


# -----Функция zip()-----
# ----Объединяет отдельные элементы каждой переданной последовательности в кортежи
# Объединения происходят по тем индексам, на которых стоят элементы
# Если передано 2 списка с 3 элементами, то будет 3 кортежа
# 1 кортеж с 0 индексами
# 2 кортеж с 1 индексами
# 3 кортеж со 2 индексами
#
# ----Сигнатура функции следующая: zip(*iterables). В качестве iterable может выступать любой итерируемый объект:
#
# список;
# кортеж;
# строка;
# множество;
# словарь и т.д.
#
# numbers = [1, 2, 3]
# words = ['one', 'two', 'three']
#
# result = zip(numbers, words)
# print(result) = <zip object at 0x...>
# print(list(result)) = [(1, 'one'), (2, 'two'), (3, 'three')]
#
# ----Можно передавать сколько угодно объектов или даже один
#
# numbers = [1, 2 ,3]
# rs = list(zip(numbers) = [(1,), (2,), (3,)]
#
#
# ----Если передать объекты, имеющие разные длину, то итоговая длина кончится на длине наименьшего объекта
#
# numbers = [1, 2, 3, 4]
# words = ['one', 'two']
# romans = ['I', 'II', 'III']
#
# rs = list(zip(numbers, words, romans)) = [(1,'one', 'I'), (2,'two','II')]
#
# ---- С помощью функции можно удобно создавать словари, если ключ и значение в разных списках
#
# keys = ['name', 'age', 'gender']
# values = ['Timur', 28, 'male']
#
# info = dict(zip(keys, values))
#
# {'name': 'Timur', 'age': 28, 'gender': 'male'}
#
#
# ----
#
# name = ['Timur', 'Ruslan', 'Rustam']
# age = [28, 21, 19]
#
# for x,y in zip(name,age): # x and y будут принимать 0 и 1 элемент кортежей
#     print(x,y)
#
# Timur 28
# Ruslan 21
# Rustam 19







