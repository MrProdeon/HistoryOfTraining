## Оглавление
- [Ввод-вывод](#ввод-вывод)
  - [Базовые команды](#базовые-команды)
  - [sep, end](#sep-end)
  - [Арифметика и её приоритеты](#арифметика-и-её-приоритеты)
- [Логические операторы и их приоритеты](#логические-операторы-и-их-приоритеты)
  - [Основы](#основы)
- [Типы данных](#типы-данных)
  - [Числовые типы данных](#числовые-типы-данных)
  - [Строковый тип данных](#строковый-тип-данных)
  - [Модуль math](#модуль-math)
- [Циклы](#циклы)
  - [for](#for)
  - [Частые сценарии](#частые-сценарии)
  - [While](#while)
  - [while: break, continue, else](#while-break-continue-else)
  - [Вложенные циклы](#вложенные-циклы)
- [Строки](#строки)
  - [Индексация строк](#индексация-строк)
  - [Вывод символов строки](#вывод-символов-строки)
  - [Срезы строк](#срезы-строк)
  - [Методы строк](#методы-строк)
  - [format()](#format)
  - [f-строки](#f-строки)
  - [Строки в памяти компьютера](#строки-в-памяти-компьютера)
  - [Сравнение строк](#сравнение-строк)
- [Списки](#списки)
  - [Создание списка](#создание-списка)
  - [Основы (len, sum, min, max, in)](#основы-len-sum-min-max-in)
  - [Добавление элементов](#добавление-элементов)
  - [Объединение списков](#объединение-списков)
  - [Удаление элементов](#удаление-элементов)
  - [Вывод элементов списка](#вывод-элементов-списка)
  - [split(), join()](#split-join)
  - [Методы списков](#методы-списков)
  - [Сортировка списков](#сортировка-списков)
  - [Списочные выражения](#списочные-выражения)
  - [Нахождение чисел палиндромов](#нахождение-чисел-палиндромов)
  - [Методы сортировки списков](#методы-сортировки-списков)
- [Функции](#функции)
  - [Функции без параметров](#функции-без-параметров)
  - [Функции с параметрами](#функции-с-параметрами)
  - [Глобальные и локальные переменные](#глобальные-и-локальные-переменные)
  - [Функции с возвратом значения](#функции-с-возвратом-значения)
- [Интересные штуки](#интересные-штуки)
  - [Числовая угадайка](#числовая-угадайка)
  - [Магический шар 8](#магический-шар-8)
  - [Генератор безопасных паролей](#генератор-безопасных-паролей)
  - [Калькулятор систем счисления (bin(), oct(), hex())](#калькулятор-систем-счисления-bin-oct-hex)
  - [Угадайка слов](#угадайка-слов)
- [Тип данных bool и NoneType](#тип-данных-bool-и-nonetype)
  - [bool](#bool)
  - [NoneType](#nonetype)
- [Вложенные списки](#вложенные-списки)
  - [Основы](#основы-2)
  - [Матрицы](#матрицы)
- [Кортежи](#кортежи)
  - [Введение](#введение)
  - [Основы](#основы-3)
  - [Сравнение кортежей](#сравнение-кортежей)
  - [Сортировка кортежей](#сортировка-кортежей)
  - [Распаковка кортежей](#распаковка-кортежей)
  - [partition()](#partition)
- [Множества](#множества)
  - [Множества в математике](#множества-в-математике)
  - [Пустое множество](#пустое-множество)
  - [Числовые множества](#числовые-множества)
  - [Операции над множествами](#операции-над-множествами)
  - [Диаграммы Эйлера-Венна при решении задач](#диаграммы-эйлера-венна-при-решении-задач)
  - [Введение в множества в Python](#введение-в-множества-в-python)
  - [Создание множества](#создание-множества)
  - [Вывод множества](#вывод-множества)
  - [set()](#set)
  - [Основы работы с множествами](#основы-работы-с-множествами)
  - [Перебор элементов множества и распаковка](#перебор-элементов-множества-и-распаковка)
  - [Сравнение множеств](#сравнение-множеств)
  - [Методы множеств](#методы-множеств)
  - [Генераторы множеств](#генераторы-множеств)
  - [frozenset](#frozenset)
- [Словари](#словари)
  - [Введение](#введение-2)
  - [Создание словаря](#создание-словаря)
  - [Создание пустого словаря](#создание-пустого-словаря)
  - [Важные детали](#важные-детали)
  - [Основы (len, sum, min, max, in)](#основы-len-sum-min-max-in-2)
  - [Сравнение словарей](#сравнение-словарей)
  - [Перебор элементов словаря](#перебор-элементов-словаря)
  - [Распаковка словарей](#распаковка-словарей)
  - [Методы keys(), values(), items()](#методы-keys-values-items)
  - [Сортировка словарей](#сортировка-словарей)
  - [Методы словарей](#методы-словарей)
  - [Генераторы словарей](#генераторы-словарей)
  - [Вложенные словари](#вложенные-словари)
- [Модули random, string, Метод Монте-Карло, Bogosort](#модули-random-string-метод-монте-карло-bogosort)
  - [Модуль random](#модуль-random)
  - [Модуль string](#модуль-string)
  - [Метод Монте-Карло](#метод-монте-карло)
  - [Bogosort](#bogosort)


В конспекте использованы примеры и картинки из курсов https://stepik.org/course/58852 и https://stepik.org/course/68343.
# Ввод-вывод
## Базовые команды
Для ввода используется команда `input()`  \
Для вывода команда `print()`
## sep, end
С помощью `sep` и `end` можно установить знак между аргументами и конец строки в `print()`  \
Пример:
```python
print("Hello", "World", sep="*", end="/")
>>> Hello*World/

```
## Арифметика и её приоритеты
```python
+  # сложение
-  # вычитание
/  # деление
*  # умножение
**  # возведение в степень
%  # остаток от деления
//  # целочисленное деление
```
Приоритеты (сверху самый высокий):
```python
1.	()
2.	**
3.	- (унарный минус)
4.	*, /, //, %
5.	+, -

```
# Логические операторы и их приоритеты
## Основы
```python
or  # логическое сложение
and  # логическое умножение
not  # логическое отрицание
```
Приоритеты (сверху самый высокий):
```python
1.	not
2.	and
3.	or

```
# Типы данных
## Числовые типы данных
```python
int(n)  # целочисленный тип данных (1)
float(n)  # число с плавающей запятой (0.1)
max(a, b ... n)  # максимальное число
min(a, b ... n)  # минимальное число
abs(n)  # абсолютная величина числа (модуль)

```
## Строковый тип данных
```python
str("string")  # преобразование в строку
len("string")  # длина строки

print("ab"+"bc")  # конкатенация (сложение строк)
>>> abbc

print("Hi" * 4)  # умножение строки
>>> HiHiHiHi

text = """
многострочный текст выделяется
тройными кавычками
"""

print("ab" in "abc")
>>> True
print("ac" in "abc")
>>> False
print("AB" in "abc")
>>> False  # in чувствителен к регистру

```
## Модуль math
Существует 2 вида импорта модулей:
```python
1. import math
2. from math import *
```
При использовании первого нужно использовать команды так:
```python
math.sqrt(25)
```
При использовании второго:
```python
sqrt(25)
```
Второй метод проще, но при нём могут возникнуть конфликты из-за одинаковых команд в разных модулях
Также можно импортировать всего несколько команд, а не все из модуля:
```python
from math import sqrt
sqrt(25)


```
Список функций модуля math


| Функция | Описание |
|---|---|
| Округления |  |
| int() | Округляет число в сторону нуля |
| round(x) | Округляет число x до ближайшего целого. Если дробная часть числа равна 0.50.5, то число округляется до ближайшего четного числа (банковское округление) |
| round(x, n) | Округляет число x до n знаков после точки |
| floor(x) | Округляет число x вниз («пол») |
| ceil(x) | Округляет число x вверх («потолок») |
| abs(x) | Модуль числа x (абсолютная величина) |
| Корни, логарифмы, степени и факториал |  |
| sqrt(x) | Квадратный корень числа x |
| pow(x, n) | Возведение числа x в степень n |
| log(x) | Натуральный логарифм числа x. Основание натурального логарифма равно числу e |
| log10(x) | Десятичный логарифм числа x. Основание десятичного логарифма равно числу 10 |
| log(x, b) | Логарифм числа x по основанию b |
| factorial(n) | Факториал натурального числа n |
| Тригонометрия |  |
| degrees(x) | Преобразует угол x, заданный в радианах, в градусы |
| radians(x) | Преобразует угол x, заданный в градусах, в радианы |
| cos(x) | Косинус угла x, задаваемого в радианах |
| sin(x) | Синус угла x, задаваемого в радианах |
| tan(x) | Тангенс угла x, задаваемого в радианах |
| acos(x) | Возвращает угол в радианах от 0 до π, cos которого равен x |
| asin(x) | Возвращает угол в радианах от −π2−2π​ до π22π​, sin которого равен x |
| atan(x) | Возвращает угол в радианах от −π2−2π​ до π22π​, tan которого равен x |
| atan2(y, x) | Полярный угол (в радианах) точки с координатами (x, y) |


# Циклы
## for
С одним аргументом (от нуля до n-1):
```python
for i in range(10):
    print(i)
>>> 0
>>> 1
>>> 2
>>> 3
>>> 4
>>> 5
>>> 6
>>> 7
>>> 8
>>> 9
```
С двумя аргументами (от m до n-1):
```python
for i in range(1, 10):
    print(i)
>>> 1
>>> 2
>>> 3
>>> 4
>>> 5
>>> 6
>>> 7
>>> 8
>>> 9
```
С тремя аргументами (от m до n-1 с шагом k):
```python
for i in range(1, 10, 2):  # третий аргумент - величина шага
    print(i)
>>> 1
>>> 3
>>> 5
>>> 7
>>> 9

```
## Частые сценарии
- Подсчёт количества
```python
counter = 0
for _ in range(10):
    num = int(input())
    if num > 10:
        counter = counter + 1

print('Было введено', counter, 'чисел, больших 10.')

```
- Обмен значений переменных
Вместо:
```python
temp = x
x = y
y = temp
```
Можно использовать:
```python
x, y = y, x

```
- Сигнальные метки
```python
num = int(input())
flag = True

for i in range(2, num):
    if num % i == 0:  #  если исходное число делится на какое-либо отличное от 1 и самого себя
        flag = False

if num == 1:
    print('Это единица, она не простая и не составная') 
elif flag == True:
    print('Число простое')
else:
    print('Число составное')

```
- Максимум и минимум
```python
largest = 0
for _ in range(10):
    num = int(input())    
    if num > largest:
        largest = num

print('Наибольшее число равно', largest)

```
- Расширенные операторы присваивания


| Оператор | Пример использования | Эквивалент |
|---|---|---|
| += | x += 5 | x = x + 5 |
| -= | x -= 2 | x = x - 2 |
| *= | x *= 10 | x = x * 10 |
| /= | x /= 4 | x = x / 4 |
| //= | x //= 4 | x = x // 4 |
| %= | x %= 4 | x = x % 4 |


## While
While выполняет команды внутри себя пока условие(-я) выполняется(-ются)
- Обработка цифр числа:
```python
n = int(input())
while n != 0:  # пока в числе есть цифры
    last_digit = n % 10  # получить последнюю цифру
    # код обработки последней цифры
    n = n // 10  # удалить последнюю цифру из числа

```
- «До остановки»:
```python
text = input()
total = 0
while text != "stop":
    total += int(text)
    text = input()
print("Сумма чисел равна", total)

```
## while: break, continue, else
`break `завершает цикл
Проверка числа на простоту:
```python
num = int(input())
flag = True

for i in range(2, num):
    if num % i == 0:  # если исходное число делится на какое-либо отличное от 1 и самого себя
        flag = False
        break  # останавливаем цикл если встретился делитель числа        
if flag:  # эквивалентно if flag == True:
    print('Число простое')
else:
    print('Число составное')

```
`continue` позволяет перейти к следующей итерации цикла `for` или `while` до завершения всех команд в теле цикла.
Программа, которая выводит все числа от 1 до 100, кроме чисел 7, 17, 29 и 78:
```python
for i in range(1, 101):
    if i == 7 or i == 17 or i == 29 or i == 78:
        continue  # переходим на следующую итерацию
    print(i)

```
Python допускает необязательный блок `else` в конце циклов `while` и `for`. Это уникальная особенность Python, не встречающаяся в большинстве других языков программирования. `else` выполнится, если цикл завершился без `break`. Синтаксис такой конструкции следующий:
```python
while условие:
    блок кода1
else:
    блок кода2

# или

for i in range(10):
    блок кода1
else:
    блок кода2
```
Пример:
```python
n = 5 
while n > 0:
   	 n -= 1
    	print(n)
else:
print('Цикл завершен.')

```
## Вложенные циклы
```python
for hours in range(24):
    for minutes in range(60):
        for seconds in range(60):
            print(hours, ':', minutes, ':', seconds)
>>> 0 : 0 : 0
>>> 0 : 0 : 1
>>> 0 : 0 : 2
...
>>> 23 : 59 : 58
>>> 23 : 59 : 59
```
При помощи вложенных циклов можно решать уравнения:
Уравнение 12x+13y=777.
Решение:
```python
for x in range(777):
    for y in range(777):
        if 12 * x + 13 * y == 777:
            print(x, y)

```
# Строки
## Индексация строк
![Image 1](images/image_1.png)
Небольшая шпаргалка:
Пример вывода символа из строки:
```python
s = 'Python'
print(s[1])  # выводит символ с индексом 1 (2 с начала)
print(s[-3])  # выводит символ с индексом -3 (3 с конца)
>>> y
>>> h 

```
## Вывод символов строки
Для вывода каждого символа на новой строке используют такую конструкцию:
```python
s = 'abcdef'
for i in range(len(s)):
    print(s[i])
>>> a
>>> b
>>> c
>>> d
>>> e
>>> f

```
## Срезы строк
Срез выводит символы с x по y (правильнее будет сказать с x по y-1)
![Image 2](images/image_2.png)
```python
s = 'abcdefghij'
print(s[2:5])
>>> cde
```
Также можно опускать параметры в срезах
![Image 3](images/image_3.png)
```python
s = 'abcdefghij'
print(s[2:])
print(s[:7])
>>> cdefghij
>>> abcdefg
```
![Image 4](images/image_4.png)
Также можно указать шаг среза, например, срез `s[1:7:2]` создаст строку bdf состоящую из каждого второго символа (индексы 1, 3, 5)
![Image 5](images/image_5.png)
Можно указать отрицательный шаг среза:


| s = 'abcdefghij' | s = 'abcdefghij' | s = 'abcdefghij' |
|---|---|---|
| Программный код | Результат | Пояснение |
| s[2:5] | cde | строка состоящая из символов с индексами 2, 3, 4 |
| s[:5] | abcde | первые пять символов строки |
| s[5:] | fghij | строка состоящая из символов с индексами от 5 до конца |
| s[-2:] | ij | последние два символа строки |
| s[:] | abcdefghij | вся строка целиком |
| s[1:7:2] | bdf | строка, состоящая из каждого второго символа с индексами от 1 до 6 |
| s[::-1] | jihgfedcba | строка в обратном порядке, так как шаг отрицательный |


```python
print(s[::-1])
>>> jihgfedcba

```
Изменение символа строки по индексу
Предположим, у нас есть строка `s =` `'abcdefghij'` и мы хотим заменить символ с индексом 4 на 'X'. Можно попытаться написать код:
```python
s[4] = 'X'
```
Однако такой код не работает. В Python строки являются неизменяемыми, то есть мы не можем менять их содержимое с помощью индексатора.
Правильный код:
```python
s = s[:4] + 'X' + s[5:]

```
## Методы строк
Методы к строкам применяются так: строка.метод
- Конвертация регистра
```python
s = 'foO BaR BAZ quX'


print(s.capitalize())  # Первое слово с большой буквы, остальные - с маленькой
>>> Foo bar baz qux

print(s.swapcase())    # Меняет регистр всех символов на противоположный
>>> FOo bAr baz QUx

print(s.title())       # Каждое слово начинается с заглавной буквы
>>> Foo Bar Baz Qux

print(s.lower())       # Все символы приводятся к нижнему регистру
>>> foo bar baz qux

print(s.upper())       # Все символы приводятся к верхнему регистру
>>> FOO BAR BAZ QUX

```
- Поиск и замена
```python
s = 'foo bar foo baz foo qux'

# Метод count(<sub>, <start>, <end>) - количество вхождений подстроки
print(s.count('foo'))      
print(s.count('foo', 0, 10)) 
>>> 3
>>> 2

# Метод startswith(<prefix>, <start>, <end>) - проверка начала строки
print(s.startswith('foo'))  
print(s.startswith('bar')) 
>>> True
>>> False

# Метод endswith(<suffix>, <start>, <end>) - проверка конца строки
print(s.endswith('qux'))    
print(s.endswith('bar'))   
>>> True
>>> False

# Метод find(<sub>, <start>, <end>) - индекс первого вхождения (или -1)
print(s.find('foo'))        
print(s.find('python'))     
>>> 0
>>> -1

# Метод rfind(<sub>, <start>, <end>) - поиск с конца строки
print(s.rfind('foo'))       
print(s.rfind('python'))    
>>> 16
>>> -1

# Метод index(<sub>, <start>, <end>) - как find(), но вызывает ошибку при отсутствии
print(s.index('foo'))       
# print(s.index('python'))  # Вызовет ValueError
>>> 0

# Метод rindex(<sub>, <start>, <end>) - поиск с конца с ошибкой при отсутствии
print(s.rindex('foo')) 
# print(s.rindex('python')) # Вызовет ValueError
>>> 16

s = '     foo bar foo baz foo qux      '

# Метод strip() - удаляет пробелы с обоих концов
print(s.strip())            
>>> foo bar foo baz foo qux

# Метод lstrip() - удаляет пробелы только слева
print(s.lstrip())          
>>> foo bar foo baz foo qux______

# Метод rstrip() - удаляет пробелы только справа
print(s.rstrip())           
>>> ______foo bar foo baz foo qux

s = '-+-+abc+-+-'

# Удаление указанных символов с обоих концов
print(s.strip('+-'))        
>>> abc

# Удаление указанных символов справа
print(s.rstrip('+-'))       
>>> -+-+abc

# Удаление указанных символов слева
print(s.lstrip('+-'))       
>>> abc+-+-

s = 'foo bar foo baz foo qux'

# Метод replace(<old>, <new>, <count>) - замена всех вхождений
print(s.replace('foo', 'grault'))          # Все вхождения
>>> grault bar grault baz grault qux

print(s.replace('foo', 'grault', 2))       # Только 2 первых замены
>>> grault bar grault baz foo qux0

```
- Классификация символов
```python
print('Python3'.isalnum())  # состоит ли строка только из букв и/или цифр
>>> True

print('Hello'.isalpha())  # состоит ли строка только из букв
>>> True

print('2023'.isdigit())  # состоит ли строка только из цифр
>>> True

print('python'.islower())  # все ли буквы в строке строчные
>>> True

print('PYTHON'.isupper())  # все ли буквы в строке заглавные
>>> True

print('   '.isspace())  # состоит ли строка только из пробелов
>>> True

```
## format()
В Python можно использовать заполнители:
```python
birth_year = 1992
name = 'Timur'
profession = 'math teacher'
text = 'My name is {}, I was born in {}, I work as a {}.'.format(name, birth_year, profession)

print(text)
>>> My name is Timur, I was born in 1992, I work as a math teacher.

```
Также можно несколько раз использовать один и тот же аргумент:
```python
name = 'Timur'
city = 'Moscow'
text1 = 'My name is {0}-{0}-{0}!'.format(name, city)
text2 = '{1} is my city and {0} is my name!'.format(name, city)

print(text1)
>>> My name is Timur-Timur-Timur!

print(text2)
>>> Moscow is my city and Timur is my name!

```
## f-строки
Строки вида
```python
name = 'Никита'
print(name, "- мой друг")
>>> Никита - мой друг
```
Можно изменить на:
```python
name = 'Никита'
print(f"{name} - мой друг")
>>> Никита - мой друг
```
В f-строках переменные нужно указывать в {} скобках, а текст просто писать
## Строки в памяти компьютера
Таблица ASCII:
![Image 6](images/image_6.png)
Функция `ord()` позволяет определить код некоторого символа в таблице символов Unicode.
```python
num1 = ord('A')
num2 = ord('B')
num3 = ord('a') 
print(num1, num2, num3)
>>> 65 66 97
```
Функция `chr()` позволяет определить по коду символа сам символ. Аргументом данной функции является численный код.
```python
chr1 = chr(65)
chr2 = chr(75)
chr3 = chr(110)
print(chr1, chr2, chr3)
>>> A K n

```
## Сравнение строк
Строки можно сравнивать, работает это по лексикографическому порядку (точнее, по ASCII)
Строчные символы больше заглавных
```python
print('d' > 'D')
print('Ы' < 'ы')
>>> True
>>> True

```
# Списки
## Создание списка
Списки могут содержать разные типы данных
Список можно задать двумя способами:
```python
a = []
a = list()

```
## Основы (len, sum, min, max, in)
```python
a = [1, 5, 3]

print(len(a))  # длина списка (количество элементов)
>>> 3

print(sum(a))  # сумма элементов списка
>>> 9

print(min(a))  # минимум из списка
>>> 1

print(max(a))  # максимум из списка
>>> 5

print(1 in a)  # есть ли элемент со значением 1 в списке a
>>> True

```
В списках индексация, срезы, конкатенация и умножение аналогично строкам, только тут вместо символов строки элементы списка.
Отличие списков от строк:
Несмотря на всю схожесть списков и строк, есть одно очень важное отличие: строки — неизменяемые объекты, а списки – изменяемые.
Список можно удобно заполнить порядковыми числами:
```python
a = list(range(1, 10, 2))
print(a)
>>> [1, 3, 5, 7, 9]

```
## Добавление элементов
`a.append()` - добавление элемента в конец списка
```python
a = [1, 1, 2, 3, 5, 8, 13]
a.append(21)  # добавляем число 21 в конец списка
a.append(34)  # добавляем число 34 в конец списка
print(a)
>>> [1, 1, 2, 3, 5, 8, 13, 21, 34]

```
## Объединение списков
Чтобы объединить списки нужно использовать следующий метод:
```python
a = [1, 2]
b = [5, 7]
a.extend(b)
print(a)
>>> [1, 2, 5, 7]

```
## Удаление элементов
Для удаления элементов используется инструкция `del`
```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del a[5]    # удаляем элемент, имеющий индекс 5
print(a)
>>> [1, 2, 3, 4, 5, 7, 8, 9]

```
## Вывод элементов списка
- Вывод через цикл
```python
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for i in range(len(a)):
    print(a[i])
>>> 0
>>> 1
>>> 2
>>> 3
>>> 4
>>> 5
>>> 6
>>> 7
>>> 8
>>> 9
>>> 10

```
- Распаковка списка
```python
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(*a)
>>> 0 1 2 3 4 5 6 7 8 9 10

```
- Распаковка списка и вывод каждого элемента на новой строке
```python
a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(*a, sep="\n")
>>> 0
>>> 1
>>> 2
>>> 3
>>> 4
>>> 5
>>> 6
>>> 7
>>> 8
>>> 9
>>> 10

```
## split(), join()
Метод `split()` разбивает строку на слова, используя в качестве разделителя последовательность пробельных символов, и возвращает список из этих слов.
```python
s = 'Python is the most powerful language'
words = s.split()
print(words)
>>> ['Python', 'is', 'the', 'most', 'powerful', 'language']
```
Также можно указать аргумент, который будет разделителем:
```python
ip = '192.168.1.24'
numbers = ip.split('.')    # указываем явно разделитель
print(numbers)
>>> ['192', '168', '1', '24']

```
Метод `join()` собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод.
```python
words = ['Python', 'is', 'the', 'most', 'powerful', 'language']
s = ' '.join(words)
print(s)
>>> Python is the most powerful language

```
Шпаргалки:
![Image 7](images/image_7.png)
![Image 8](images/image_8.png)
![Image 9](images/image_9.png)
## Методы списков
```python
s = [1, 3, 5]
s.insert(4, 2)  # вставляет 2 в индекс 4
print(s)
>>> [1, 3, 5, 2]

s = [1, 3, 5]
print(s.index(3))  # выводит индекс первого вхождения 3 список s
>>> 1

s = [1, 3, 5]
s.remove(3)  # удаляет первое вхождение элемента 3
print(s)
>>> [1, 5]

s = [1, 3, 5]
s.pop(2)  # удаляет элемент с индексом 2
print(s)
>>> [1, 3]

s = [1, 3, 3, 3, 3, 5]
print(s.count(3))  # выводит количество элементов со значением 3
>>> 4

s = [1, 3, 5]
s.reverse()  # переворачивает список
print(s)
>>> [5, 3, 1]

s = [1, 3, 5]
s.clear()  # очищает список
print(s)
>>> []

s = [1, 3, 5]
g = s.copy()  # делает копия списка, при изменении оригинала копия тоже изменяется
print(g)
>>> [1, 3, 5]

```
## Сортировка списков
В Python списки имеют встроенный метод `sort()`, который сортирует элементы списка по возрастанию или убыванию.
```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
a.sort()
print('Отсортированный список:', a)
>>> Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
```
Также можно сортировать по убыванию. Если требуется отсортировать список по убыванию, необходимо явно указать параметр `reverse =` `True.`
```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
a.sort(reverse=True)  # сортируем по убыванию
print('Отсортированный список:', a)
>>> Отсортированный список: [1000, 99, 45, 34, 12, 9, 8, 7, 6, 1, 0, -2, -3, -67]
```
Функция `sorted()` возвращает отсортированный список, не изменяя оригинальный.
```python
a = [1, 5, 3]
print(sorted(a))
>>> [1, 3, 5]
```
## Списочные выражения
```python
numbers = [i for i in range(10)]  # числа от 0 до 9
print(numbers)
>>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

numbers = [i**2 for i in range(10)]  # квадраты чисел от 0 до 9
print(numbers)
>>> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

numbers = [int(input()) for i in range(int(input()))]  # ввод n чисел с клавиатуры
print(numbers)
<<< 5
<<< 1
<<< 2
<<< 3
<<< 4
<<< 5
>>> [1, 2, 3, 4, 5]

numbers = [i * j for i in range(1, 5) for j in range(2)]  # вложенные циклы
print(numbers)
>>> [0, 1, 0, 2, 0, 3, 0, 4]

numbers = [i for i in range(21) if i % 2 == 0]  # четные числа от 0 до 20 (условие в списочном выражении)
print(numbers)
>>> [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

```
## Нахождение чисел палиндромов
Во-первых, вот что такое палиндром:
Числа-палиндромы — числа, которые в определённой позиционной системе исчисления (как правило — в десятичной) читаются одинаково как справа налево, так и слева направо.
Достаточно просто доказать, что чисел-палиндромов бесконечно много. Одним из способов доказательства является замена любой выбранной цифры в их написании двумя любыми другими цифрами, в результате чего получается новое число-палиндром.
```python
palindromes = [i for i in range(100, 1001) if i == int(str(i)[::-1])]
print(palindromes)

```
## Методы сортировки списков
- Сортировка пузырьком
Алгоритм сортировки пузырьком состоит из повторяющихся проходов по сортируемому списку. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по списку повторяются n−1 раз, где n – длина списка. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент списка ставится на свое место в конце списка рядом с предыдущим «наибольшим элементом».
Наибольший элемент каждый раз «всплывает» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма.
Алгоритм пузырьковой сортировки считается учебным и практически не применяется вне учебной литературы, а на практике применяются более эффективные.
Реализация:
```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
n = len(a)

for i in range(n - 1):
    for j in range(n - 1 - i):
        if a[j] > a[j + 1]:                  # если порядок элементов пары неправильный
            a[j], a[j + 1] = a[j + 1], a[j]  # меняем элементы пары местами 

print('Отсортированный список:', a)

```
- Сортировка выбором
Сортировка выбором улучшает пузырьковую сортировку, совершая всего один обмен за каждый проход по списку. Для этого алгоритм ищет максимальный элемент и помещает его на соответствующую позицию. Как и для пузырьковой сортировки, после первого прохода самый большой элемент находится на правильном месте. После второго прохода на своё место становится следующий максимальный элемент. Проходы по списку повторяются n−1 раз, где n – длина списка, поскольку последний из них автоматически оказывается на своем месте.
Алгоритм сортировки выбором также считается учебным и практически не применяется вне учебной литературы. На практике используют более эффективные алгоритмы.
Реализация:
```python
a = [78, -32, 5, 39, 58, -5, -63, 57, 72, 9, 53, -1, 63, -97, -21, -94, -47, 57, -8, 60, -23, -72, -22, -79, 90, 96, -41, -71, -48, 84, 89, -96, 41, -16, 94, -60, -64, -39, 60, -14, -62, -19, -3, 32, 98, 14, 43, 3, -56, 71, -71, -67, 80, 27, 92, 92, -64, 0, -77, 2, -26, 41, 3, -31, 48, 39, 20, -30, 35, 32, -58, 2, 63, 64, 66, 62, 82, -62, 9, -52, 35, -61, 87, 78, 93, -42, 87, -72, -10, -36, 61, -16, 59, 59, 22, -24, -67, 76, -94, 59]

n = len(a)

for i in range(n):
    mx = max(a[:n - i])
    mx_ind = a.index(mx)

    a[n - 1 - i], a[mx_ind] = a[mx_ind], a[n - 1 - i]

print('Отсортированный список:', a)

```
- Сортировка простыми вставками
Алгоритм сортировки простыми вставками делит список на 2 части — отсортированную и неотсортированную. Из неотсортированной части извлекается очередной элемент и вставляется на нужную позицию в отсортированной части, в результате чего отсортированная часть списка увеличивается, а неотсортированная уменьшается. Так происходит, пока не исчерпан набор входных данных и не отсортированы все элементы.
Сортировка простыми вставками наиболее эффективна, когда список уже частично отсортирован и элементов массива немного. Если элементов в списке меньше 10, то этот алгоритм - один из самых быстрых.
Реализация:
```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
n = len(a)

for i in range(1, n): 
    elem = a[i]  # берем первый элемент из неотсортированной части списка
    j = i

    # пока элемент слева существует и больше нашего текущего элемента
    while j >= 1 and a[j - 1] > elem:
        # смещаем j-1-й элемент отсортированной части вправо
        a[j] = a[j - 1]
        # сами идём влево, дальше ищем место для нашего текущего элемента
        j -= 1

    # нашли место для нащего текущего элемента из неотсортированной части
    # и вставляем его на индекс j в отсортированной части
    a[j] = elem

print('Отсортированный список:', a)

```
# Функции
## Функции без параметров
Именование функций
Python и тут требует соблюдения тех же правил, что при именовании переменных:
- в имени функции используются только латинские буквы a-z, A-Z, цифры и символ нижнего подчеркивания (_)
- имя функции не может начинаться с цифры
- имя функции по возможности должно отражать ее назначение
- символы верхнего и нижнего регистра различаются.
Объявление функции:
```python
def название_функции():
    блок кода

pass  # ничего не делает, используется как заглушка.
```
Вызов функции:
```python
название_функции()
```
Объявление функции должно предшествовать ее вызову.
## Функции с параметрами
Объявление функции с параметрами:
```python
def название_функции(параметры):
    блок кода
```
При вызове функции мы обязаны использовать столько аргументов, сколько объявлено в функции.
Пример:
```python
def draw(c):
    for i in range(c):
        print('*' * 10)

draw(10)
>>> **********
>>> **********
>>> **********
>>> **********
>>> **********
>>> **********
>>> **********
>>> **********
>>> **********
>>> **********

```
## Глобальные и локальные переменные
Локальными называются переменные, объявленные внутри функции и доступные только ей самой. Программный код за пределами функции к ним доступа не имеет.
```python
def print_paris(): 
    s = 'I love Paris'
    print(s) 

def print_london():
    s = 'I love London'
    print(s) 

s = 'I love Moscow'
print_paris()
print_london()
print(s)
>>> I love Paris
>>> I love London
>>> I love Moscow

```
Глобальными называются переменные, объявленные в основной программе и доступные как программе, так и всем ее функциям.
Если нужно, чтобы инструкция внутри функции присваивала значение глобальной переменной, то требуется дополнительный шаг. В этом случае глобальная переменная должна быть объявлена внутри функции. Благодаря `global` можно изменять глобальную переменную в функции.
```python
def print_texas():
    global birds
    birds = 5000
    print('В Техасе обитает', birds, 'птиц.')

def print_california():
    print('В Калифорнии обитает', birds, 'птиц.')

print_texas()
print_california()
>>> В Техасе обитает 5000 птиц.
>>> В Калифорнии обитает 5000 птиц.
```
В следующем коде мы работаем с глобальной переменной в функции:
```python
x = 5

def add():
    global x
    x = 3
    x = x + 5
    print(x)

add()
print(x)
```
Код выведет 8 8, так как мы использовали `global` `x`, а значит функция будет изменять глобальную переменную.
## Функции с возвратом значения
Некоторые команды в Python возвращают что-то, например, `len("Бургер") `вернёт 6.
Есть команды, которые ничего не возвращают, например, `del a[2] `просто удаляет элемент списка.
Для возврата значения используют `return значение `в конце тела функции. Все команды написанные после `return` в функции не будут выполнятся.
Пример:
```python
def square(x):
    return x**2

print(square(2))
>>> 4
```
Код выводит квадрат числа 2
Также можно возвращать `True` или `False`.
Пример:
```python
def divide(x):
    if x % 2 == 0:
        return True

if divide(2):
    print('Число делится на 2')
else:
    print('Число не делится на 2')

```
Также можно возвращать несколько значений:
```python
def sqr(x, y):
    return x**2, y**2

print(sqr(2, 4))
>>> (4, 16)

```
# Интересные штуки
## Числовая угадайка
```python
import random

while True:
    counter = 0
    to = int(input("Укажите число, до которого компьютер будет выбирать случайное: "))
    g = random.randint(1, to)
    print("Добро пожаловать в числовую угадайку!")
    print(f"Введите число от 1 до {to}")

    while True:
        n = int(input())
        if n < g:
            print("Ваше число меньше загаданного, попробуйте еще разок")
            counter += 1

        elif n > g:
            print("Ваше число больше загаданного, попробуйте еще разок")
            counter += 1

        else:
            counter += 1
            print(f"Вы угадали число за {counter} попыток, поздравляем!")
            break

    if (
        input(
            "Спасибо, что играли в числовую угадайку. Хотите сыграть еще раз? (да/нет): "
        )
        == "нет"
    ):
        break

```
## Магический шар 8
```python
import random

answers = [
    "Бесспорно",
    "Мне кажется - да",
    "Пока неясно, попробуй снова",
    "Даже не думай",
    "Предрешено",
    "Вероятнее всего",
    "Спроси позже",
    "Мой ответ - нет",
    "Никаких сомнений",
    "Хорошие перспективы",
    "Лучше не рассказывать",
    "По моим данным - нет",
    "Можешь быть уверен в этом",
    "Да",
    "Сконцентрируйся и спроси опять",
    "Весьма сомнительно",
]

print("Привет Мир, я магический шар, и я знаю ответ на любой твой вопрос.")
name = input("Как тебя зовут? ")
print(f"Привет, {name}")
while True:
    input("Напиши свой вопрос: ")
    print(random.choice(answers))
    if input("Хочешь задать ещё один вопрос? (да/нет): ") == "нет":
        break

```
## Генератор безопасных паролей
```python
import random


digits = "0123456789"
lowercase_letters = "abcdefghijklmnopqrstuvwxyz"
uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
punctuation = "!#$%&*+-=?@^_"

chars = ""

count = int(input("Введите количество паролей: "))
lenght = int(input("Введите длину одного пароля: "))
contain_digits = input("Включать цифры? ")
contain_upper = input("Включать прописные буквы? ")
contain_lower = input("Включать строчные буквы? ")
contain_strange = input("Включать символы !#$%&*+-=?@^_? ")
stupid = input("Исключать неоднозначные символы il1Lo0O? ")

if contain_digits == "да":
    chars += digits
if contain_upper == "да":
    chars += uppercase_letters
if contain_lower == "да":
    chars += lowercase_letters
if contain_strange == "да":
    chars += punctuation
if stupid == "да":
    chars = "".join([i for i in chars if not i in "il1Lo0O"])

for i in range(count):
    print("".join(random.sample(chars, lenght)))

```
## Калькулятор систем счисления (bin(), oct(), hex())
```python
a = int(input("Введите число в десятичной системе счисления: "))
print(f"Число в двоичной системе: {bin(a)[2:]}")
print(f"Число в восьмеричной системе: {oct(a)[2:]}")
print(f"Число в шестнадцатеричной системе: {hex(a)[2:].upper()}")

```
## Угадайка слов
```python
import random, os

word_list = [
    "год",
    "человек",
    "время",
    "дело",
    "жизнь",
    "день",
    "рука",
    "раз",
    "работа",
    "слово",
    "место",
    "лицо",
    "друг",
    "глаз",
    "вопрос",
    "дом",
    "сторона",
    "страна",
    "мир",
    "случай",
    "голова",
    "ребенок",
    "сила",
    "конец",
    "вид",
    "система",
    "часть",
    "город",
    "отношение",
    "женщина",
    "деньги",
    "земля",
    "машина",
    "вода",
    "отец",
    "проблема",
    "час",
    "право",
    "нога",
    "решение",
    "дверь",
    "образ",
    "история",
    "власть",
    "закон",
    "война",
    "бог",
    "голос",
    "тысяча",
    "книга",
    "возможность",
    "результат",
    "ночь",
    "стол",
    "имя",
    "область",
    "статья",
    "число",
    "компания",
    "народ",
    "жена",
    "группа",
    "развитие",
    "процесс",
    "суд",
    "условие",
    "средство",
    "начало",
    "свет",
    "пора",
    "путь",
    "душа",
    "уровень",
    "форма",
    "связь",
    "минута",
    "улица",
    "вечер",
    "качество",
    "мысль",
    "дорога",
    "мать",
    "действие",
    "месяц",
    "государство",
    "язык",
    "любовь",
    "взгляд",
    "мама",
    "век",
    "школа",
    "цель",
    "общество",
    "деятельность",
    "организация",
    "президент",
    "комната",
    "порядок",
    "момент",
    "театр",
]


def get_word():
    return random.choice(word_list).upper()


# функция получения текущего состояния
def display_hangman(tries):
    stages = [  # финальное состояние: голова, торс, обе руки, обе ноги
        """
                   --------
                   |      |
                   |      O
                   |     \\|/
                   |      |
                   |     / \\
                   -
                """,
        # голова, торс, обе руки, одна нога
        """
                   --------
                   |      |
                   |      O
                   |     \\|/
                   |      |
                   |     / 
                   -
                """,
        # голова, торс, обе руки
        """
                   --------
                   |      |
                   |      O
                   |     \\|/
                   |      |
                   |      
                   -
                """,
        # голова, торс и одна рука
        """
                   --------
                   |      |
                   |      O
                   |     \\|
                   |      |
                   |     
                   -
                """,
        # голова и торс
        """
                   --------
                   |      |
                   |      O
                   |      |
                   |      |
                   |     
                   -
                """,
        # голова
        """
                   --------
                   |      |
                   |      O
                   |    
                   |      
                   |     
                   -
                """,
        # начальное состояние
        """
                   --------
                   |      |
                   |      
                   |    
                   |      
                   |     
                   -
                """,
    ]
    os.system("cls")
    return stages[tries]


def play(word):
    word_completion = "_" * len(
        word
    )  # строка, содержащая символы _ на каждую букву задуманного слова
    guessed_letters = []  # список уже названных букв
    tries = 6

    while True:
        print(display_hangman(tries))
        print(word_completion)

        symbol = input("Введите букву русского алфавита: ").upper()

        if symbol in guessed_letters:
            while True:
                symbol = input("Вы уже открыли эту букву, введите другую: ").upper()
                if symbol not in guessed_letters:
                    break

        if symbol not in "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ" or len(symbol) != 1:
            while True:
                symbol = input("Введите букву русского алфавита: ").upper()
                if symbol in "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ" and len(symbol) == 1:
                    break

        word_completion_before = word_completion

        for i in range(len(word)):
            if word[i] == symbol:
                word_completion = (
                    word_completion[:i] + symbol + word_completion[i + 1 :]
                )
                guessed_letters += symbol

        if word_completion_before == word_completion:
            tries -= 1

        if tries == 0:
            print(display_hangman(0))
            print(f"К сожалению, вы проиграли... Слово: {word}")
            input("Нажмите Enter для повторной игры")
            break

        if "_" not in word_completion:
            print(f"Поздравляем! Вы угадали слово {word_completion}")
            input("Нажмите Enter для повторной игры")
            break


while True:
    play(get_word())

```
# Тип данных bool и NoneType
## bool
- bool может иметь значение `True` или `False`.
- `a and b `дает `True`, если оба операнда `True`, или `False`, если хотя бы один из них `False`  \
- `a or b `дает `False`, если оба операнда `False`, или `True`, если хотя бы один из них `True`  \
- `not a` дает `True`, если `a` имеет значение `False`, или `False`, если `a` имеет значение `True`.
```python
print(True == 1)
print(False == 0)
>>> True
>>> True

print(True == 1)
print(False == 0)
>>> True
>>> True
```
Для приведения других типов данных к булеву существует функция `bool()`, работающая по следующим соглашениям:
- строки: пустая строка – ложь (`False`), непустая строка – истина (`True`)
- числа: нулевое число – ложь (`False`), ненулевое число (в том числе и меньшее нуля) – истина (`True`)
- списки: пустой список – ложь (`False`), непустой – истина (`True`).
В языке Python имеется встроенная функция `isinstance()` для проверки соответствия типа объекта какому-либо типу данных.
```python
print(isinstance(3, int))
print(isinstance(3.5, float))
print(isinstance('Beegeek', str))
print(isinstance([1, 2, 3], list))
print(isinstance(True, bool))
>>> True
>>> True
>>> True
>>> True
>>> True

```
В языке Python имеется встроенная функция `type()`, позволяющая получить тип указанного в качестве аргумента объекта.
```python
print(type(3))
print(type(3.5))
print(type('Beegeek'))
print(type([1, 2, 3]))
print(type(True))
>>> <class 'int'>
>>> <class 'float'>
>>> <class 'str'>
>>> <class 'list'>
>>> <class 'bool'>

```
## NoneType
```python
var = None
print(type(var))
>>> <class 'NoneType'>
```
Сравнение `None` с любым объектом, отличным от `None`, дает значение `False`. `None` возвращается если функция ничего не вернула.
# Вложенные списки
## Основы
Создание вложенного списка:
```python
my_list = [[0], [1, 2], [3, 4, 5]]
```
Чтобы получить число 2 мы используем такую команду:
```python
my_list = [[0], [1, 2], [3, 4, 5]]
print(my_list[1][1])  # сначала получаем список с индексом 1 ([1, 2]), а затем первый индекс (2)
>>> 2

```
Функции `min()` и `max()` могут работать и со списками. Если этим функциям передается несколько списков, то целиком возвращается один из переданных списков. При этом сравнение происходит поэлементно: сначала сравниваются первые элементы списков. Если они не равны, то функция `min()` вернет тот список, первый элемент которого меньше, `max()` – наоборот. Если первые элементы равны, то будут сравниваться вторые и т. д.
Пример:
Задача:
На вход программе подается число n. Напишите программу, которая создает и выводит построчно вложенный список, состоящий из n списков [[1], [1, 2], [1, 2, 3], ..., [1, 2, ..., n]].
Формат входных данных
На вход программе подается натуральное число n.
Формат выходных данных
Программа должна вывести построчно указанный вложенный список.
Решение:
```python
print(*[[i for i in range(1, j+1)] for j in range(1, int(input())+1)], sep="\n")

```
## Матрицы
Матрицы - прямоугольные таблицы, заполненные какими-то значениями, обычно числами.
![Image 10](images/image_10.png)
Перебор элементов матрицы:
```python
rows, cols = 3, 4  # rows - количество строк, cols - количество столбцов

matrix  = [[2, 3, 1, 0],
           [9, 4, 6, 8],
           [4, 7, 2, 7]]

for r in range(rows):
    for c in range(cols):
        print(matrix[r][c], end=' ')
    print()
>>> 2 3 1 0 
>>> 9 4 6 8 
>>> 4 7 2 7
```
Строковый метод `ljust(arg)` выравнивает текст по ширине, добавляя пробелы в конец текста.
Строковый метод `rjust(arg)` выравнивает текст по ширине, добавляя пробелы в начало текста.
Таблица умножения n на m:
```python
n, m = int(input()), int(input())
s = [[i * j for i in range(m)] for j in range(n)]
for i in s:
    print(*i)
<<< 4
<<< 6
>>> 0 0 0 0 0 0
>>> 0 1 2 3 4 5
>>> 0 2 4 6 8 10
>>> 0 3 6 9 12 15

```
# Кортежи
## Введение
Кортежи по своей природе (задумке) – неизменяемые аналоги списков. Кортеж описывается следующим образом:
```python
list = []  # список
tuple = ()  # кортеж
```
Для создания кортежа с единственным элементом после значения элемента ставят замыкающую запятую:
```python
my_tuple = (1,)
print(type(my_tuple))
>>> <class 'tuple'>
```
Если её не поставить, то будет создан не кортеж, а просто переменная со значением 1 (типа `int`)
В чём кортеж превосходит список?
- Скорость
- Безопасность
Где встречаются кортежи? Если функция возвращает несколько значений, она возвращает кортеж.
Важно! Тот факт, что кортеж является неизменяемым вовсе не означает, что мы не можем поменять содержимое списка в кортеже.
## Основы
Кортеж можно превратить в список используя функцию `list(mytuple)`.
Список можно превратить в кортеж используя функцию `tuple(mylist)`.
Кортеж можно преобразовать в строку с помощью строкового метода `join(mytuple)`.
Строку можно преобразовать в кортеж с помощью функции `tuple(mystring)`.
Кортежи поддерживают:
- доступ к элементу по индексу (только для получения значений элементов)
- методы, в частности `index()`, `count()`  \
- встроенные функции, в частности `len(),` `sum(),` `min(),` `max()`  \
- срезы
- оператор принадлежности `in`  \
- операторы конкатенации (+) и повторения (*).
Кортежи могут иметь вложенные кортежи и вложенные списки.
## Сравнение кортежей
```python
print((1, 8) == (1, 8))
print((1, 8) != (1, 10))
print((1, 9) < (1, 2))
print((2, 5) < (6,))
print(('a', 'bc') > ('a', 'de'))

>>> True
>>> True
>>> False
>>> True
>>> False
```
Обратите внимание: операции == и != применимы к любым кортежам, независимо от типов элементов. А вот операции <, >, <=, >= применимы только в том случае, когда соответствующие элементы кортежей имеют один тип.
## Сортировка кортежей
Так как кортежи неизменяемы, то и метода `sort()` у них нет. Но кортеж можно отсортировать при помощи функции  `sorted()`. Данная функция возвращает отсортированный кортеж/список, а не сортирует его «на месте».
Примеры решения задач:
Условие: Напишите программу, которая выводит список хорошистов и отличников в классе.
Формат входных данных
На вход программе подается натуральное число
n, далее следует n строк с фамилией школьника и его оценкой на каждой из них.
Формат выходных данных
Программа должна вывести сначала все введённые строки с фамилиями и оценками учеников в том же порядке. Затем следует пустая строка, а затем выводятся строки с фамилиями и оценками хорошистов и отличников (в том же порядке).
Решение:
```python
a = [tuple(input().split()) for _ in range(int(input()))]  # создаем n кортежей, которые будут иметь 2 значения - фамилия и оценка
for i in a:
    print(*i)

print()

for name, grade in a:  # перебираем каждый кортеж
    if int(grade) > 3:  # если оценка выше 3, выводим имя и оценку
        print(name, grade)

```
## Распаковка кортежей
Кортежи можно распаковывать так:
```python
print(*tuple)
```
Но мы также можем присвоить переменным значения элементов кортежа:
```python
colors = ('red', 'green', 'blue', 'cyan')

(a, b, c, d) = colors

print(a)
print(b)
print(c)
print(d)
>>> red
>>> green
>>> blue
>>> cyan
```
При этом переменных должно быть ровно столько, сколько символов в кортеже.
Но что делать если нам нужны например только первые 2 переменные из кортежа/списка? Для этого используют такую конструкцию:
```python
*names, surname = ('Стефани', 'Джоанн', 'Анджелина', 'Джерманотта')

print(names)
print(surname)
>>>['Стефани', 'Джоанн', 'Анджелина']
>>> Джерманотта
```
Перед `names` мы поставили `*`, это означает что это список, который примет все значения, которые не приняли другие переменные.
Учтите, что `*tail` всегда будет списком, даже когда в него попадает лишь один элемент или даже ноль.
## partition()
Помимо метода `split()` строковый тип данных содержит метод `partition()`. Метод `partition()` принимает на вход один аргумент `sep`, разделяет строку при первом появлении `sep` и возвращает кортеж, состоящий из трех элементов: часть перед разделителем, сам разделитель и часть после разделителя. Если разделитель не найден, то кортеж содержит саму строку, за которой следуют две пустые строки.
```python
s1 = 'abc-de'.partition('-')
s2 = 'abc-de'.partition('.')
s3 = 'abc-de-fgh'.partition('-')

print(s1)
print(s2)
print(s3)
>>> ('abc', '-', 'de')
>>> ('abc-de', '', '')
>>> ('abc', '-', 'de-fgh')

```
# Множества
## Множества в математике
В математике множество – совокупность объектов, понимаемых как единое целое. Обычно множества обозначают большими латинскими буквами.
Если два множества X и Y состоят из одних и тех же элементов, то они называются равными X=Y. Обратите внимание, порядок расположения элементов в записи множеств при их сравнении во внимание не принимается.
Если все элементы множества X принадлежат также и множеству Y, то говорят, что X является подмножеством Y, а записывается это так: X ⊂ Y.
Если множество X конечно, то через ∣X∣ обозначается количество элементов множества X.
Множество X, содержащее n элементов, имеет 2^n подмножеств, включая пустое. Например, X = {a, b, c} (3 элемента) имеет 8 подмножеств: ∅, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c}.
Важно! Множества – неупорядоченные совокупности, то есть неважно, в каком порядке указаны элементы множества.
## Пустое множество
Пустое множество – множество, не содержащего ни одного элемента. Оно обозначается знаком ∅.
## Числовые множества
- Натуральные числа:
N={1,2,3,4,5,…}
- Целые числа:
Z={0,±1,±2,±3,±4,±5,…}
- Рациональные числа. Рациональным числом в математике называется любое число, представимое в виде частного двух целых чисел с отличным от нуля знаменателем. Множество рациональных чисел обозначается буквой Q и содержит следующие числа:
Q={, m∈Z, n∈N}.
- Иррациональные числа. Не все числа в математике можно представить в виде рационального числа. Примером служат числа:
≈1.414213562…
π≈3.1415926535…
e≈2.71828182845…
Такие числа называются иррациональными и являются бесконечными непериодическими дробями. Иными словами, в «бесконечных хвостах» иррациональных чисел нет никакой закономерности. Иррациональные числа часто обозначают буквой I.
- Вещественные числа:
Объединение рациональных и иррациональных чисел образует множество вещественных чисел. Множество вещественных чисел R определяется так: R=Q∪I. Символ ∪ – означает объединение множеств.
- Комплексные числа:
Комплексные числа — это числа вида a + bi, где a и b — действительные числа, а i — мнимая единица (i² = −1).
Это множество обозначают буквой C.
## Операции над множествами
- Объединение множеств – множество, состоящее из элементов, принадлежащих хотя бы одному из объединяемых множеств. Для объединения множеств используется символ ∪.
![Image 11](images/image_11.png)
- Пересечение множеств – множество, состоящее из элементов, принадлежащих одновременно каждому из пересекающихся множеств. Для пересечения множеств используется символ ∩.
![Image 12](images/image_12.png)
- Разность множеств – множество, в которое входят только элементы первого множества, не входящие во второе множество. Для разности множеств используется символ ∖.
![Image 13](images/image_13.png)
- Симметрическая разность множеств – множество, включающее все элементы исходных множеств, не принадлежащие одновременно обоим исходным множествам. Для симметрической разности множеств используется символ △.
![Image 14](images/image_14.png)
- Дополнение множества – множество всех элементов, в нем не содержащихся. Для операции дополнения множества используется символ ¬.
![Image 15](images/image_15.png)
## Диаграммы Эйлера-Венна при решении задач
Задача. Каждый ученик онлайн-школы BEEGEEK изучает или математику или информатику, или и то и другое одновременно. Всего 75 учеников изучает математику, а 27 – информатику и только 13 – оба предмета. Сколько учеников учится в онлайн-школе BEEGEEK?
Решение. Введем обозначения: множество учеников, изучающих математику – М, информатику – И. Изображаем множества на диаграмме Эйлера-Венна в наиболее общем случае.
![Image 16](images/image_16.png)
Рассуждаем следующим образом: оба предмета изучают 13 учеников. Значит, только математику изучают 75 − 13 = 62 ученика, только информатику изучают 27 − 13 = 14 учеников. Таким образом, всего в школе учится 62 + 13 + 14 = 89 учеников. Ответ: 89.
## Введение в множества в Python
Важно знать:
- все элементы множества различны (уникальны), два элемента не могут иметь одинаковое значение
- множества неупорядочены, то есть элементы не хранятся в каком-то определенном порядке
- элементы множества должны относиться к неизменяемым типам данных
- хранящиеся в множестве элементы могут иметь разные типы данных.
- Множества изменяемы
Множество не может содержать список, множество, однако может содержать кортеж.
## Создание множества
Чтобы создать множество, нужно перечислить его элементы через запятую в фигурных скобках:
```python
numbers = {2, 4, 6, 8, 10}
languages = {"Python", "C#", "C++", "Java"}
favorites = {"Nikita", 144, "My friend"}

```
Создать пустое множество можно с помощью встроенной функции, которая называется `set()`:
```python
myset = set()  # пустое множество
```
Важно! Создать пустое множество с помощью пустых фигурных скобок нельзя:
```python
myset = {}  # создается словарь

```
## Вывод множества
Вывести множество можно через `print(myset)`.
Обратите внимание: при выводе множества порядок элементов может отличаться от существовавшего при его создании, поскольку множества — неупорядоченные коллекции данных.
## set()
Встроенная функция `set()` помимо создания пустого множества может преобразовывать некоторые типы объектов в множества. В функцию `set()` можно передать один аргумент. Передаваемый аргумент должен быть итерируемым объектом, таким как список, кортеж или строковое значение. Отдельные элементы объекта, передаваемого в качестве аргумента, становятся элементами множества:
```python
myset1 = set(range(10))          # множество из элементов последовательности
myset2 = set([1, 2, 3, 4, 5])    # множество из элементов списка
myset3 = set('abcd')             # множество из элементов строки
myset4 = set((10, 20, 30, 40))   # множество из элементов кортежа
```
Пустое множество также можно создать передав функции `set()` в качестве аргумента пустой список, строку или кортеж:
```python
emptyset1 = set([])  # пустое множество из пустого списка
emptyset2 = set('')  # пустое множество из пустой строки
emptyset3 = set(())  # пустое множество из пустого кортежа

```
Множества не могут содержать повторяющиеся элементы. Если в функцию `set()` передать аргумент, содержащий повторяющиеся элементы, то в множестве появится только один из этих повторяющихся элементов.
```python
myset1 = {2, 2, 4, 6, 6}
myset2 = set([1, 2, 2, 3, 3])
myset3 = set("aaaaabbbbccccddd")

print(myset1)
print(myset2)
print(myset3)
>>> {2, 4, 6}
>>> {1, 2, 3}
>>> {"b", "c", "d", "a"}

```
Если требуется создать множество, в котором каждый элемент — строковое значение, содержащее более одного символа, то используем код:
```python
myset = set(['aaa', 'bbbb', 'cc'])

print(myset)
>>> {'bbbb', 'aaa', 'cc'}
```
Однако вот что будет, если аргумент будет строкой:
```python
myset = set('aaa bbbb cc')

print(myset)
>>> {' ', 'c', 'a', 'b'}

```
## Основы работы с множествами
- Функция `len()` возвращает длину множества (количество элементов).
- Оператор `in` позволяет проверить, содержит ли множество некоторый элемент. В множествах он работает намного быстрее чем в списках.
- Встроенная функция `sum()` принимает в качестве аргумента множество чисел и вычисляет сумму его элементов.
- Встроенные функции `min()` и `max()` принимают в качестве аргумента множество и находят минимальный и максимальный элементы соответственно.
Важно! Индексация и срезы недоступны для множеств. Операция конкатенации + и умножения на число * тоже недоступны для множеств.
## Перебор элементов множества и распаковка
Перебор элементов множества осуществляется точно так же, как и перебор элементов списка, то есть с помощью цикла `for`.
Для вывода элементов множества каждого на отдельной строке можно использовать следующий код:
```python
numbers = {0, 1, 1, 2, 3, 3, 3, 5, 6, 7, 7}

for num in numbers:
    print(num)
>>> 0
>>> 1
>>> 2
>>> 3
>>> 5
>>> 6
>>> 7
```
Но также можно распаковать таким способом:
```python
print(*numbers)
>>> 0 1 2 3 5 6 7
```
Помните, что множества - неупорядоченные коллекции, а значит если вам нужно вывести элементы по возрастанию, используйте функцию `sorted()`, которая вернёт отсортированный список. Метода `sort()` у множеств нет. В функции можно указать необязательный параметр `reverse`. При `reverse=True` множество будет отсортировано по убыванию.
## Сравнение множеств
Множества можно сравнивать между собой. Равные множества имеют одинаковую длину и содержат равные элементы. Для сравнения множеств используются операторы == и !=. Других операторов сравнения у множеств нет.
## Методы множеств
Основные:
- Для добавления нового элемента в множество используется метод `add()`.
```python
numbers = {1, 1, 2, 3, 5, 8, 3}  # создаем множество
numbers.add(21)  # добавляем число 21 в множество
numbers.add(34)  # добавляем число 34 в множество
print(numbers)
>>> {1, 2, 3, 34, 5, 8, 21}
```
- Метод `remove()` удаляет элемент из множества с генерацией исключения (ошибки) в случае, если такого элемента нет.
```python
numbers = {1, 2, 3, 4, 5}
numbers.remove(3)
print(numbers)
>>> {1, 2, 4, 5}
```
- Метод `discard()` удаляет элемент из множества без генерации исключения (ошибки), если элемент отсутствует.
```python
numbers = {1, 2, 3, 4, 5}
numbers.discard(3)
print(numbers)
>>> {1, 2, 4, 5}

numbers = {1, 2, 3, 4, 5}
numbers.discard(10)
print(numbers)
>>> {1, 2, 3, 4, 5}
```
- Метод `pop()` удаляет и возвращает первый элемент из множества с генерацией исключения (ошибки) при попытке удаления из пустого множества. Аргументы указать нельзя.
```python
numbers = {1, 2, 3, 4, 5}
print('до удаления:', numbers)
num = numbers.pop()  # удаляет первый элемент множества, возвращая его
print('удалённый элемент:', num)
print('после удаления:', numbers)
>>> до удаления: {1, 2, 3, 4, 5}
>>> удалённый элемент: 1
>>> после удаления: {2, 3, 4, 5}
```
- Метод `clear()` удаляет все элементы из множества.
```python
numbers = {1, 2, 3, 4, 5}
numbers.clear()
print(numbers)
>>> set()

```
Операции над множествами:
- Объединение множеств: `union()` возвращает новое множество со всеми элементами первого и второго.
Для объединения двух множеств можно также использовать оператор |.
Для изменения текущего множества используется метод `update()`.
Первый вариант:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.union(myset2)
print(myset3)
```
`>>>` `{1,` `2,` `3,` `4,` `5,` `6,` `7,` `8}`  \
Второй вариант:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1 | myset2
print(myset3)
>>> {1, 2, 3, 4, 5, 6, 7, 8}
```
Использование `update()`:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1.update(myset2)  # изменяем множество myset1
print(myset1)
>>> {1, 2, 3, 4, 5, 6, 7, 8}
```
	Еще один способ:
	`myset1 =` `{1,` `2,` `3,` `4,` `5}`
```python
myset2 = {3, 4, 6, 7, 8}
myset1 |= myset2
print(myset1)
>>> {1, 2, 3, 4, 5, 6, 7, 8}
```
- Пересечение множеств: `intersection()` возвращает новое множество состоящее из элементов, принадлежащих одновременно каждому из пересекающихся множеств.
Для пересечения двух множеств можно также использовать оператор &.
Для изменения текущего множества используется метод `intersection_update()`.
Первый вариант:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.intersection(myset2)
print(myset3)
>>> {3, 4}
```
Второй вариант:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1 & myset2
print(myset3)
>>> {3, 4}
```
Использование `intersection_update()`:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1.intersection_update(myset2)  # изменяем множество myset1
print(myset1)
>>> {3, 4}
```
Еще один способ:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1 &= myset2
print(myset1)
>>> {3, 4}
```
- Разность множеств: `difference()` возвращает новое множество, в которое входят все элементы первого множества, не входящие во второе множество.
Для разности двух множеств можно также использовать оператор -.
Для изменения текущего множества используется метод `difference_update()`.
Первый вариант:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.difference(myset2)
print(myset3)
>>> {1, 2, 5}
```
Второй вариант:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1 - myset2
print(myset3)
>>> {1, 2, 5}
```
Использование `difference_update()`:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1.difference_update(myset2)  # изменяем множество myset1
print(myset1)
>>> {1, 2, 5}
```
Еще один способ:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1 -= myset2
print(myset1)
>>> {1, 2, 5}
```
- Симметричная разность множеств: `symmetric_difference()` возвращает новое множество, включающее все элементы исходных множеств, не принадлежащие одновременно обоим исходным множествам.
Для симметричной разности двух множеств можно также использовать оператор ^.
Для изменения текущего множества используется метод `symmetric_difference_update()`.
Первый вариант:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1.symmetric_difference(myset2)
print(myset3)
>>> {1, 2, 5, 6, 7, 8}
```
Второй вариант:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset3 = myset1 ^ myset2
print(myset3)
>>> {1, 2, 5, 6, 7, 8}
```
Использование `symmetric_difference_update()`:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1.symmetric_difference_update(myset2)  # изменяем множество myset1
print(myset1)
>>> {1, 2, 5, 6, 7, 8}
```
Еще один способ:
```python
myset1 = {1, 2, 3, 4, 5}
myset2 = {3, 4, 6, 7, 8}
myset1 ^= myset2
print(myset1)
>>> {1, 2, 5, 6, 7, 8}

```
Подмножества и надмножества:
Любое множество – подмножество самого себя, про такое подмножество говорят "нестрогое подмножество".
Для определения, является ли одно из множеств подмножеством другого, используется метод `issubset().` Данный метод возвращает значение `True`, если одно множество является подмножеством другого, и `False`, если не является
```python
set1 = {2, 3}
set2 = {1, 2, 3, 4, 5, 6}
print(set1.issubset(set2))
>>> True

```
Для определения, является ли одно из множеств подмножеством другого, также применяются операторы <= (нестрогое подмножество) и < (строгое подмножество).
```python
set1 = {2, 3}
set2 = {1, 2, 3, 4, 5, 6}
print(set1 <= set2)
>>> True

```
Для определения, является ли одно из множеств надмножеством другого, используется метод `issuperset()`. Данный метод возвращает значение `True`, если одно множество является надмножеством другого, в противном случае он возвращает `False`.
```python
set1 = {'a', 'b', 'c', 'd', 'e'}
set2 = {'c', 'e'}
print(set1.issuperset(set2))
>>> True
```
Для определения, является ли одно из множеств надмножеством другого, также применяются операторы >= (нестрогое надмножество) и > (строгое надмножество).
```python
set1 = {'a', 'b', 'c', 'd', 'e'}
set2 = {'c', 'e'}
print(set1 >= set2)
>>> True
```
Для определения отсутствия общих элементов в множествах используется метод `isdisjoint()`. Данный метод возвращает значение `True`, если множества не имеют общих элементов, и  `False`, когда множества имеют общие элементы.
```python
set1 = {1, 2, 3, 4, 5}
set2 = {5, 6, 7}
set3 = {7, 8, 9}
print(set1.isdisjoint(set2))
print(set1.isdisjoint(set3))
print(set2.isdisjoint(set3))
>>> False
>>> True
>>> False

```
## Генераторы множеств
Чтобы заполнить множество всеми цифрами числа, можно использовать следующий код:
```python
digits = {int(c) for c in input()}
```
В генераторах можно использовать условия:
```python
digits = {int(d) for d in 'abcd12ef78ghj90' if d.isdigit()}
```
Данный код добавляет в `digits` только цифры.
## frozenset
frozenset – замороженный вариант множеств (set)
Синтаксис замороженных множеств полностью идентичен обычным.
Такие множества можно сравнивать с обычными.
Зачем они нужны?
- Замороженные множества являются неизменяемыми, а значит могут быть элементами других множеств.
# Словари
## Введение
Словарь – изменяемый тип данных в Python. Левая часть – ключ, правая – значение.
Пример словаря:
```python
languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг', 
             'C++': 'Бьёрн Страуструп'}
```
Код создает словарь, в котором ключом служит строка — название языка программирования, а значением — имя создателя языка. Важно! В рамках одного словаря каждый ключ уникален.
Для извлечения элемента словаря используют ключ:
```python
languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг', 
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages['C#'])
>>> Создателем языка C# является Андерс Хейлсберг
```
В отличие от списков, номеров позиций в словарях нет.
Для вывода всего словаря можно использовать функцию `print()`:
```python
info = {"name": "Nikita", "status": "Creator"}
print(info)
>>> {'name': 'Nikita', 'status': 'Creator'}
```
 Начиная с версии Python 3.6, словари являются упорядоченными, то есть сохраняют порядок следования ключей в порядке их внесения в словарь.
## Создание словаря
Если ключи словаря — строки без каких-либо специальных символов, то для создания словаря можно использовать функцию `dict(). `Пример:
```python
info = dict(name='Timur', age=28, job='Teacher')

```
Создание на основе списка кортежей:
```python
info_list = [('name', 'Timur'), ('age', 28), ('job', 'Teacher')]  # список кортежей
info_dict = dict(info_list)  # создаем словарь на основе списка кортежей

```
Создание на основе кортежа списков:
```python
info_tuple = (['name', 'Timur'], ['age', 28], ['job', 'Teacher'])  # кортеж списков
info_dict = dict(info_tuple)  # создаем словарь на основе кортежа списков

```
Если необходимо создать словарь, каждому ключу которого соответствует одно и то же значение, можно воспользоваться методом `fromkeys()`.
```python
dict1 = dict.fromkeys(['name', 'age', 'job'], 'Missed information')
```
 Если методу `fromkeys()` не передать второй параметр, то по умолчанию присваивается значение `None`.
Создать словарь на основании двух списков (кортежей) можно с помощью встроенной функции-упаковщика `zip().`
```python
keys = ['name', 'age', 'job']
values = ['Timur', 28, 'Teacher']
info = dict(zip(keys, values))
print(info)
>>> {'name': 'Timur', 'age': 28, 'job': 'Teacher'}
```
 В случае несовпадения длины списков функция самостоятельно отсечет лишние элементы.
## Создание пустого словаря
Создать пустой словарь можно двумя способами:
- с помощью пустых фигурных скобок
- с помощью функции `dict()`
## Важные детали
- Ключи должны быть уникальными
- Ключи должны быть неизменяемым типом данных
- Значения могут относиться к любому типу данных, их тип данных произволен
- Обращение по индексу и срезы недоступны для словарей
- Операция конкатенации + и умножения на число * недоступны для словарей
## Основы (len, sum, min, max, in)
- Длиной словаря называется количество его элементов. Для определения длины словаря используют встроенную функцию `len()`.
```python
fruits = {'Apple': 70, 'Grape': 100, 'Banana': 80}
print(len(fruits))
>>> 3
```
- Встроенная функция `sum()` принимает в качестве аргумента словарь с числовыми ключами и вычисляет сумму его ключей.
```python
my_dict = {10: 'Россия', 20: 'США', 30: 'Франция'}
print('Сумма всех ключей словаря =', sum(my_dict))
>>> Сумма всех ключей словаря = 60
```
- Встроенные функции `min()` и `max()` принимают в качестве аргумента словарь и находят минимальный и максимальный ключ соответственно, при этом ключ может принадлежать к любому типу данных, для которого возможны операции порядка <, <=, >, >= (числа, строки, и т.д.).
```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
months = {1: 'Январь', 2: 'Февраль', 3: 'Март'}
print('Минимальный ключ =', min(capitals))
print('Максимальный ключ =', max(months))
>>> Минимальный ключ = Россия
>>> Максимальный ключ = 3
```
- Оператор `in` позволяет проверить, содержит ли словарь заданный ключ.
```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
if 'Франция' in capitals:
    print('Столица Франции - это', capitals['Франция'])
>>> Столица Франции - это Париж

```
## Сравнение словарей
Словари можно сравнивать между собой. Равные словари имеют одинаковое количество элементов и содержат равные элементы (ключ: значение). Для сравнения словарей используются операторы == и !=.
## Перебор элементов словаря
Вывод ключей словаря:
```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
for key in capitals:
    print(key)
>>> Россия
>>> Франция
>>> Чехия
```
Вывод значений словаря:
```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
for key in capitals:
    print(capitals[key])
>>> Москва
>>> Париж
>>> Прага

```
## Распаковка словарей
При распаковке словарей возвращаются только ключи:
```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
print(*capitals, sep='\n')
>>> Россия
>>> Франция
>>> Чехия

```
## Методы keys(), values(), items()
Словарный метод `keys()` возвращает список ключей всех элементов словаря.
```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
for key in capitals.keys():     # итерируем по списку ['Россия', 'Франция', 'Чехия']
    print(key)
>>> Россия
>>> Франция
>>> Чехия

```
Словарный метод `values()` возвращает список значений всех элементов словаря.
```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
for value in capitals.values():     # итерируем по списку ['Москва', 'Париж', 'Прага']
    print(value)
>>> Москва
>>> Париж
>>> Прага

```
Словарный метод `items()` возвращает список всех элементов словаря, состоящий из кортежей пар (ключ, значение).
```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
for item in capitals.items():
    print(item)
>>> ('Россия', 'Москва')
>>> ('Франция', 'Париж')
>>> ('Чехия', 'Прага')
```
Можно писать такой код:
```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
for key, value in capitals.items():
    print(key, '-', value)
>>> Россия - Москва
>>> Франция - Париж
>>> Чехия – Прага

```
## Сортировка словарей
Сортировка по ключам выполняется с использованием функции `sorted()`.
Важно: словари не содержат метода `sort()`.
```python
capitals = {'Россия': 'Москва', 'Англия': 'Лондон', 'Чехия': 'Прага', 'Бразилия': 'Бразилиа'}
for key in sorted(capitals):
    print(key)
>>> Англия
>>> Бразилия
>>> Россия
>>> Чехия

```
## Методы словарей
- Добавление и изменение элементов в словаре
Чтобы изменить значение по определенному ключу в словаре, достаточно использовать индексацию вместе с оператором присваивания. При этом если ключ уже присутствует в словаре, его значение заменяется новым, если же ключ отсутствует – то в словарь будет добавлен новый элемент.
```python
info = {"name": "Sam", "age": 28, "job": "Teacher"}
info["name"] = "Timur"  # изменяем значение по ключу name
info["email"] = "timyr-guev@yandex.ru"  # добавляем в словарь элемент с ключом email
print(info)
>>> {'name': 'Timur', 'age': 28, 'job': 'Teacher', 'email': 'timyr-guev@yandex.ru'}
```
- Метод `get()`  \
Для того чтобы избежать возникновения ошибки в случае отсутствия ключа в словаре, можно использовать метод `get(),` способный кроме ключа принимать и второй аргумент — значение, которое вернется, если заданного ключа нет. Когда второй аргумент не указан, то метод в случае отсутствия ключа возвращает `None.`
```python
info = {"name": "Bob", "age": 25, "job": "Dev"}
item1 = info.get("salary")
item2 = info.get("salary", "Информации о зарплате нет")
print(item1)
print(item2)
>>> None
>>> Информации о зарплате нет
```
- Метод `update()`  \
Метод `update()` реализует своеобразную операцию конкатенации для словарей. Он объединяет ключи и значения одного словаря с ключами и значениями другого. При совпадении ключей в итоге сохранится значение словаря, указанного в качестве аргумента метода `update()`.
```python
info1 = {"name": "Bob", "age": 25, "job": "Dev"}
info2 = {"age": 30, "city": "New York", "email": "bob@web.com"}
info1.update(info2)
print(info1)
>>> {'name': 'Bob', 'age': 30, 'job': 'Dev', 'city': 'New York', 'email': 'bob@web.com'}
```
В Python 3.9 появились операторы | и |=, которые реализуют операцию конкатенации словарей.
```python
info1 = {"name": "Bob", "age": 25, "job": "Dev"}
info2 = {"age": 30, "city": "New York", "email": "bob@web.com"}
info1 |= info2
print(info1)
>>> {'name': 'Bob', 'age': 30, 'job': 'Dev', 'city': 'New York', 'email': 'bob@web.com'}
```
- Метод `setdefault()`  \
Метод `setdefault()` позволяет получить значение из словаря по заданному ключу, автоматически добавляя элемент словаря, если он отсутствует.
```python
info = {"name": "Bob", "age": 25, "job": "Dev"}
print(info.setdefault("name", "Tim"))
>>> Bob

info = {"age": 25, "job": "Dev"}
print(info.setdefault("name", "Tim"))
>>> Tim
```
- Оператор `del`
```python
info = {"name": "Sam", "age": 28, "job": "Teacher", "email": "timyr-guev@yandex.ru"}
del info["email"]  # удаляем элемент имеющий ключ email
del info["job"]  # удаляем элемент имеющий ключ job
print(info)
>>> {'name': 'Sam', 'age': 28}
```
- Метод `pop()`
```python
info = {"name": "Sam", "age": 28, "job": "Teacher", "email": "timyr-guev@yandex.ru"}
email = info.pop('email')          # удаляем элемент по ключу email, возвращая его значение
job = info.pop('job')              # удаляем элемент по ключу job, возвращая его значение
print(email)
print(job)
print(info)
>>> timyr-guev@yandex.ru
>>> Teacher
>>> {'name': 'Sam', 'age': 28}
```
Также можно указать второй аргумент, он будет возвращен, если указанного ключа в словаре нет. Это позволяет реализовать безопасное удаление элемента из словаря:
```python
surname = info.pop('surname', None)
```
- Метод `popitem()` удаляет из словаря последний добавленный элемент и возвращает удаляемый элемент в виде кортежа (ключ, значение).
```python
info = {"name": "Bob", "age": 25, "job": "Dev"}
info["surname"] = "Sinclar"
item = info.popitem()
print(item)
print(info)
>>> ('surname', 'Sinclar')
>>> {'name': 'Bob', 'age': 25, 'job': 'Dev'}
```
- Метод `clear()` удаляет все элементы из словаря.
- Метод `copy()` создает поверхностную копию словаря.
## Генераторы словарей
Генераторы словарей имеют такой же синтаксис как и в генераторах списков.
```python
squares = {i: i**2 for i in range(6)}  # квадраты чисел от 0 до 5
print(squares)
>>> {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```
В генераторах словарей можно использовать условия:
```python
squares = {i: i**2 for i in range(10) if i % 2 == 0}
print(squares)
>>> {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

```
## Вложенные словари
Вложенный словарь создается как обычный, только каждое значение в нем – другой словарь.
Пример:
```python
info = {'emp1': {'name': 'Timur', 'job': 'Teacher'},
        'emp2': {'name': 'Ruslan', 'job': 'Developer'},
        'emp3': {'name': 'Rustam', 'job': 'Tester'}}
```
Или так:
```python
info = dict(emp1 = {'name': 'Timur', 'job': 'Teacher'},
            emp2 = {'name': 'Ruslan', 'job': 'Developer'},
            emp3 = {'name': 'Rustam', 'job': 'Tester'})

```
Для обращения по индексу используют такой код:
```python
info = {'emp1': {'name': 'Timur', 'job': 'Teacher'},
        'emp2': {'name': 'Ruslan', 'job': 'Developer'},
        'emp3': {'name': 'Rustam', 'job': 'Tester'}}

print(info['emp1']['name'])
print(info['emp2']['job'])
>>> Timur
>>> Developer

```
Изменение вложенных словарей:
```python
info = {'emp1': {'name': 'Timur', 'job': 'Teacher'},
        'emp2': {'name': 'Ruslan', 'job': 'Developer'},
        'emp3': {'name': 'Rustam', 'job': 'Tester'}}

info['emp1']['job'] = 'Manager'
print(info['emp1'])
>>> {'name': 'Timur', 'job': 'Manager'}

```
Итерация по вложенным словарям:
```python
info = {'emp1': {'name': 'Timur', 'job': 'Teacher'},
        'emp2': {'name': 'Ruslan', 'job': 'Developer'},
        'emp3': {'name': 'Rustam', 'job': 'Tester'}}

for emp in info:
    print('Employee ID:', emp)
    for key in info[emp]:
        print(key + ':', info[emp][key])
    print()
>>> Employee ID: emp1
>>> name: Timur
>>> job: Teacher

>>> Employee ID: emp2
>>> name: Ruslan
>>> job: Developer

>>> Employee ID: emp3
>>> name: Rustam
>>> job: Tester

```
# Модули random, string, Метод Монте-Карло, Bogosort
## Модуль random
```python
import random

num = random.randint(0, 17)  # случайное целое число от 0 до 17 (включительно)
print(num)
>>> 14

num1 = random.randrange(0, 100, 10)  # возвращает случайное число от m до n с шагом k. синтаксис идентичен range() (не включительно)
num2 = random.randrange(0, 100, 10)  # возвращает случайное число от m до n с шагом k. синтаксис идентичен range() (не включительно)
num3 = random.randrange(0, 100, 10)  # возвращает случайное число от m до n с шагом k. синтаксис идентичен range() (не включительно)
print(num1, num2, num3)
>>> 80 30 50

num = random.random()  # случайное число с плавающей запятой от 0.0 до 1.0, аргументы не указываются (не включительно)
print(num)
>>> 0.34980886772220243

num = random.uniform(3.6, 9.2) # случайное число с плавающей запятой от 3.6 до 9.2, аргументы обязательны (включительно)
print(num)
>>> 6.574427819432531
```
Методы строк и списков:
```python
import random

numbers = [1, 2, 3, 4, 5, 6, 7, 8]
random.shuffle(numbers)  # перемешивает список
print(numbers)
>>> [3, 6, 7, 1, 5, 8, 2, 4]

print(random.choice('Ваня, привет'))  # случайный символ из строки или случайный элемент из списка
>>> я

numbers = [12, 89, 27, 46]
print(random.sample(numbers, 3))  # выводит 3 случайных элемента из списка numbers
>>> [46, 89, 27]

```
В модуле random можно задать сид (англ. seed - семя). При одинаковых сидах одинаковый код рандома выдаст одинаковых результат. По умолчанию, начальным значением генератора является системное время (текущая дата и время). Пример:
```python
import random
random.seed(17)   # явно устанавливаем начальное значение для генератора случайных чисел
for _ in range(10):
    print(random.randint(1, 100))
>>> 67
>>> 54
>>> 39
>>> 47
>>> 38
>>> 23
>>> 99
>>> 91
>>> 91
>>> 70
```
Попробуйте этот код, он выведет тоже самое что и в примере.
## Модуль string
В модуле string есть удобные константы:
```python
import string

print(string.ascii_letters)
print(string.ascii_uppercase)
print(string.ascii_lowercase)
print(string.digits)
print(string.hexdigits)
print(string.octdigits)
print(string.punctuation)
print(string.printable)
>>> abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
>>> ABCDEFGHIJKLMNOPQRSTUVWXYZ
>>> abcdefghijklmnopqrstuvwxyz
>>> 0123456789
>>> 0123456789abcdefABCDEF
>>> 01234567
>>> !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
>>> 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ \t\n\r\x0b\x0c

```
## Метод Монте-Карло
При помощи метода Монте-Карло можно вычислить примерную площадь фигуры.
Фигура:
![Image 17](images/image_17.png)
Формула:
​−2 ≤ x ≤ 2
−2 ≤ y ≤ 2
x^3 + y^4 + 2 ≥ 0
3x + y^2 ≤ 2​
Задача вычислить примерную площадь фигуры.
Решение:
```python
from random import uniform

n = 10**6  # количество испытаний
k = 0  # количество попавших точек
S = 16  # площадь квадрата, в который вписана фигура

for _ in range(n):
    x = uniform(-2, 2)  # рандомное число от минимальной до максимальной возможной координаты
    y = uniform(-2, 2)  # рандомное число от минимальной до максимальной возможной координаты
    if (-2 <= x <= 2) and (-2 <= y <= 2) and (x**3 + y**4 + 2 >= 0) and (3*x + y**2 <= 2):  # если точка внутри фигуры
        k += 1  # увеличиваем количество попавших точек

print((k/n) * S)  # (точек / метр) * площадь квадрата

```
## Bogosort
Болотная сортировка (Bogosort) — неэффективный алгоритм сортировки, используемый только в образовательных целях и противопоставляемый другим, более реалистичным алгоритмам.
Принцип работы алгоритма прост, как плесень. Перетряхиваем список случайным образом до тех пор пока он внезапно не отсортируется. Процесс может счастливо завершиться сразу, а может длиться до тепловой смерти Вселенной. Это уж как повезёт.
Реализация алгоритма:
`import random`
```python
def is_sort(nums):                   # отсортирован ли список?
    for i in range(len(nums) - 1):
        if nums[i] > nums[i + 1]:
            return False
    return True

def bogosort(nums):                  # реализация алгоритма болотной сортировки
    while not is_sort(nums):
        random.shuffle(nums)
    return nums

numbers = list(range(10))
random.shuffle(numbers)              # перемешиваем начальный список
print(numbers)                       # выводим начальный список

sorted_numbers = bogosort(numbers)

print(sorted_numbers)

```
